/*****************************************************************************
* Model: bomb4m.qm
* File:  ..\bomb4\src/main.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/3/2) .................................................................*/
#include "qep_port.h"                /* the port of the QEP event processor */
#include "bomb4_a.h"                                   /* board support package */

#include <stdio.h>

#include <stdlib.h>                                          /* for _exit() */

static Bomb4 l_bomb;                                       /* time bomb FSM */

/*..........................................................................*/
int main() {


   BSP_Init();
   Bomb4_ctor(&l_bomb, 0x0D);       /* the secret defuse code, 1101 binary */

    printf("Time Bomb (QEP QFsm class)\n"
           "Press 'u'   for UP   event\n"
           "Press 'd'   for DOWN event\n"
           "Press 'a'   for ARM  event\n"
           "Press <Esc> to quit.\n");


    QFsm_init_((QFsm *)&l_bomb, (QEvt *)0); /* take the initial transition */

    for (;;) {                                                /* event loop */
        static TickEvt tick_evt = { TICK_SIG, 0, 0};

        BSP_delay(BSP_TICKS_PER_SEC);                                         /* 100 ms delay */

        if (++tick_evt.fine_time == 10) {
            tick_evt.fine_time = 0;
        }
        printf("T(%1d)%c", tick_evt.fine_time,
                             (tick_evt.fine_time == 0) ? '\n' : ' ');

        QFsm_dispatch_((QFsm *)&l_bomb, (QEvt *)&tick_evt);

        if (kbhit()) {
            static QEvt const up_evt   = { UP_SIG,   0 };
            static QEvt const down_evt = { DOWN_SIG, 0 };
            static QEvt const arm_evt  = { ARM_SIG,  0 };
            QEvt const *e = (QEvt *)0;

            switch (getchar()) {
                case 'u': {                                     /* UP event */
                    printf("\nUP  : ");
                    e = &up_evt;                   /* generate the UP event */
                    break;
                }
                case 'd': {                                   /* DOWN event */
                    printf("\nDOWN: ");
                    e = &down_evt;               /* generate the DOWN event */
                    break;
                }
                case 'a': {                                    /* ARM event */
                    printf("\nARM : ");
                    e = &arm_evt;                 /* generate the ARM event */
                    break;
                }
                case '\33': {                                  /* <Esc> key */
                    printf("\nESC : Bye! Bye!");
                    fflush(stdout);

                    _sys_exit(0);
                }
            }
            if (e != (QEvt *)0) {            /* keyboard event available? */
                QFsm_dispatch_((QFsm *)&l_bomb, e);    /* dispatch the event */
            }
        }
    }


}

